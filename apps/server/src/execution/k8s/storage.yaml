# EFS Storage Class for persistent workspace storage
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: efs-sc
  labels:
    app: shadow
    component: storage
provisioner: efs.csi.aws.com
parameters:
  provisioningMode: efs-ap
  fileSystemId: fs-REPLACE_WITH_EFS_ID  # Replace with actual EFS filesystem ID
  directoryPerms: "0755"
  gidRangeStart: "1000"
  gidRangeEnd: "2000"
  basePath: "/shadow-workspaces"
reclaimPolicy: Retain
allowVolumeExpansion: false  # EFS doesn't support volume expansion
volumeBindingMode: Immediate
---
# Fallback storage class for local development (using gp2)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: shadow-workspace-storage
  labels:
    app: shadow
    component: storage
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
  encrypted: "true"
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer
---
# Resource quota for agent namespace
apiVersion: v1
kind: ResourceQuota
metadata:
  name: shadow-agents-quota
  namespace: shadow-agents
  labels:
    app: shadow
    component: quota
spec:
  hard:
    # Pod limits
    pods: "50"
    requests.cpu: "20"
    requests.memory: 40Gi
    limits.cpu: "50"
    limits.memory: 100Gi
    
    # Storage limits
    persistentvolumeclaims: "100"  # Allow PVCs for EFS storage
    requests.storage: "1000Gi"      # EFS storage quota
    
    # Service limits
    services: "50"
    
    # Other resources
    configmaps: "10"
    secrets: "10"
---
# Limit range for individual pods
apiVersion: v1
kind: LimitRange
metadata:
  name: shadow-agents-limits
  namespace: shadow-agents
  labels:
    app: shadow
    component: limits
spec:
  limits:
  - type: Pod
    max:
      cpu: "4"
      memory: 8Gi
    min:
      cpu: "100m"
      memory: 128Mi
  - type: Container
    default:
      cpu: "500m"
      memory: 1Gi
    defaultRequest:
      cpu: "250m"
      memory: 512Mi
    max:
      cpu: "2"
      memory: 4Gi
    min:
      cpu: "100m"
      memory: 128Mi
  - type: PersistentVolumeClaim
    max:
      storage: 20Gi
    min:
      storage: 1Gi
---
# EFS CSI Driver Service Account (required for EFS access)
apiVersion: v1
kind: ServiceAccount
metadata:
  name: efs-csi-controller-sa
  namespace: kube-system
  labels:
    app: shadow
    component: efs-csi
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT_ID:role/AmazonEKS_EFS_CSI_DriverRole  # Replace with actual role ARN
---
# Sample EFS PersistentVolume (optional - for static provisioning)
apiVersion: v1
kind: PersistentVolume
metadata:
  name: shadow-efs-pv
  labels:
    app: shadow
    component: storage-efs
spec:
  capacity:
    storage: 1000Gi  # EFS is unlimited, this is just a placeholder
  volumeMode: Filesystem
  accessModes:
    - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  storageClassName: efs-sc
  csi:
    driver: efs.csi.aws.com
    volumeHandle: fs-REPLACE_WITH_EFS_ID  # Replace with actual EFS filesystem ID
---
# Instructions ConfigMap for EFS setup
apiVersion: v1
kind: ConfigMap
metadata:
  name: shadow-efs-setup-instructions
  namespace: shadow-agents
  labels:
    app: shadow
    component: setup-docs
data:
  setup.md: |
    # EFS Setup Instructions
    
    ## Prerequisites
    1. Create EFS filesystem in AWS Console or CLI
    2. Create security group allowing NFS access (port 2049) from EKS nodes
    3. Create mount targets in all EKS subnet availability zones
    4. Install EFS CSI driver on EKS cluster
    
    ## EFS CSI Driver Installation
    ```bash
    # Install EFS CSI driver using EKS add-on (recommended)
    aws eks create-addon \
      --cluster-name shadow-cluster \
      --addon-name aws-efs-csi-driver \
      --service-account-role-arn arn:aws:iam::ACCOUNT_ID:role/AmazonEKS_EFS_CSI_DriverRole
    
    # OR install using kubectl
    kubectl apply -k "github.com/kubernetes-sigs/aws-efs-csi-driver/deploy/kubernetes/overlays/stable/?ref=release-1.5"
    ```
    
    ## Configuration Steps
    1. Replace fs-REPLACE_WITH_EFS_ID with actual EFS filesystem ID in this file
    2. Replace ACCOUNT_ID with your AWS account ID
    3. Create IAM role AmazonEKS_EFS_CSI_DriverRole with EFS permissions
    4. Apply this storage configuration: kubectl apply -f storage.yaml
    
    ## Environment Variables
    Set these in your server environment:
    - EFS_VOLUME_ID=fs-REPLACE_WITH_EFS_ID
    
    ## Testing
    Create a test pod to verify EFS mounting:
    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: efs-test
    spec:
      containers:
      - name: test
        image: busybox
        command: ["sleep", "3600"]
        volumeMounts:
        - name: efs-storage
          mountPath: /test-efs
      volumes:
      - name: efs-storage
        persistentVolumeClaim:
          claimName: efs-test-pvc
    ---
    apiVersion: v1
    kind: PersistentVolumeClaim
    metadata:
      name: efs-test-pvc
    spec:
      accessModes:
        - ReadWriteMany
      storageClassName: efs-sc
      resources:
        requests:
          storage: 5Gi
    ```