# MCP Integration Plan for Shadow

> **‚ö†Ô∏è AI-Generated Plan**: This plan was generated by an LLM based on codebase analysis. While comprehensive, it is not 100% complete. The implementing agent should conduct their own deep investigation and understanding of the codebase before proceeding. Consider this a starting point, not a definitive implementation guide.

## Overview

This plan outlines the integration of Model Context Protocol (MCP) support into the Shadow coding agent system using the AI SDK's `experimental_createMCPClient`. The goal is to enable connection to MCP servers like Context7 for real-time documentation and other external tools.

## Current Architecture Analysis

### ‚úÖ Compatibility Check
- **AI SDK Version**: 4.3.19 (supports MCP experimental features)
- **Tool System**: Dynamic tool creation via `createTools()` 
- **Integration Point**: Tools passed to `streamText()` in stream processor
- **Existing Tools**: 12 well-structured native tools with description/instruction files

### üèóÔ∏è Current Tool Flow
```
createTools(taskId) ‚Üí Native Tools ‚Üí streamText({ tools }) ‚Üí Tool Execution Results ‚Üí Frontend
```

### üéØ Target MCP Flow  
```
createTools(taskId) ‚Üí [Native Tools + MCP Tools] ‚Üí streamText({ tools }) ‚Üí Results ‚Üí Frontend
```

## Implementation Plan

### 1. MCP Client Manager (`src/agent/mcp/`)

**New File: `src/agent/mcp/mcp-manager.ts`**
```typescript
export class MCPManager {
  private clients: Map<string, MCPClient>;
  
  async connectToServer(config: MCPServerConfig): Promise<void>
  async getAvailableTools(serverName?: string): Promise<ToolSet>
  async closeAllConnections(): Promise<void>
  getConnectionStatus(): MCPConnectionStatus[]
}
```

**New File: `src/agent/mcp/types.ts`**
- MCP-specific TypeScript interfaces
- Server configuration types
- Connection status enums

### 2. Configuration System

**New File: `src/config/mcp.ts`**
```typescript
export interface MCPServerConfig {
  name: string;
  transport: 'stdio' | 'sse' | 'http';
  url?: string;
  command?: string;
  args?: string[];
  enabled: boolean;
}

export const MCP_SERVERS: MCPServerConfig[] = [
  {
    name: 'context7',
    transport: 'sse',
    url: 'https://mcp.context7.com/sse',
    enabled: true
  }
];
```

**Modify: `src/config/index.ts`**
- Import and expose MCP configuration
- Add environment variable support for MCP settings

### 3. Tool Integration Updates

**Modify: `src/agent/tools/index.ts`**

Key changes to `createTools()` function:
```typescript
export async function createTools(taskId: string, workspacePath?: string) {
  console.log(`[TOOLS] Creating tools for task ${taskId}`);
  
  // Create native tools (existing logic)
  const nativeTools = { /* existing tools */ };
  
  // Initialize MCP manager and get MCP tools
  const mcpManager = new MCPManager();
  await mcpManager.initializeConnections();
  const mcpTools = await mcpManager.getAvailableTools();
  
  // Merge tools
  return {
    ...nativeTools,
    ...mcpTools
  };
}
```

### 4. Stream Processor Integration

**Modify: `src/agent/llm/streaming/stream-processor.ts`**

Updates to the streaming configuration:
```typescript
// Line ~52: Tool creation
const tools = preCreatedTools || (await createTools(taskId, workspacePath));

// Line ~110: streamText configuration - no changes needed, tools are already passed

// Add MCP cleanup in error handling and completion
```

### 5. Initialization Updates

**Modify: `src/initialization/index.ts`**
- Initialize MCP connections during server startup
- Add graceful shutdown handling for MCP clients
- Health check integration for MCP servers

### 6. Service Layer (Optional)

**New File: `src/services/mcp-connection-service.ts`**
- Connection pooling and retry logic
- Health monitoring for MCP servers
- Reconnection strategies

## Detailed Implementation Steps

### Phase 1: Foundation (Day 1)
1. Create MCP manager class with basic connection handling
2. Add MCP configuration structure
3. Implement SSE transport for Context7 connection
4. Add basic error handling and logging

### Phase 2: Tool Integration (Day 2)
1. Modify `createTools()` to merge native + MCP tools
2. Update stream processor to handle MCP tools
3. Implement proper cleanup in `onFinish` callbacks
4. Add tool validation for MCP tools

### Phase 3: Configuration & Robustness (Day 3)
1. Add environment variable configuration
2. Implement connection retry logic
3. Add health monitoring and status reporting
4. Create proper error boundaries

### Phase 4: Testing & Polish (Day 4)
1. Integration testing with Context7
2. Error scenario testing (network failures, etc.)
3. Performance testing with multiple MCP servers
4. Documentation and logging improvements

## Key Dependencies

### Required Packages
- `ai` (already installed at 4.3.19)
- `ai/mcp-stdio` (if using stdio transport)

### Optional Enhancements
```json
{
  "@modelcontextprotocol/sdk": "latest" // For advanced MCP features
}
```

## Configuration Example

**Environment Variables:**
```env
MCP_CONTEXT7_ENABLED=true
MCP_CONTEXT7_URL=https://mcp.context7.com/sse
MCP_CONTEXT7_TRANSPORT=sse
```

**Runtime Configuration:**
```typescript
const mcpServers = [
  {
    name: 'context7',
    transport: 'sse',
    url: process.env.MCP_CONTEXT7_URL,
    enabled: process.env.MCP_CONTEXT7_ENABLED === 'true'
  }
];
```

## Testing Strategy

### Unit Tests
- MCP manager connection/disconnection
- Tool merging logic
- Configuration validation

### Integration Tests  
- Full workflow with Context7
- Multiple MCP servers simultaneously
- Error recovery scenarios

### Performance Tests
- Tool response times with MCP
- Memory usage with multiple connections
- Concurrent request handling

## Potential Challenges

### Technical Risks
1. **Connection Stability**: MCP servers may be unreliable
2. **Tool Conflicts**: Name collisions between native and MCP tools
3. **Performance**: Additional network calls may slow responses
4. **Error Handling**: Complex error scenarios with multiple servers

### Mitigation Strategies
1. **Fallback Logic**: Continue with native tools if MCP fails
2. **Tool Namespacing**: Prefix MCP tools (e.g., `context7:get-library-docs`)
3. **Caching**: Cache MCP responses where appropriate
4. **Circuit Breakers**: Disable problematic MCP servers automatically

## Success Metrics

### Functional Goals
- [ ] Context7 integration working end-to-end
- [ ] No regression in existing tool functionality
- [ ] Proper error handling for MCP failures
- [ ] Clean shutdown without hanging connections

### Performance Goals
- [ ] <500ms additional latency for MCP tool calls
- [ ] <50MB additional memory usage
- [ ] 99.9% uptime for native tools (MCP failures don't break core functionality)

## Future Enhancements

### Phase 2 Features
- Multiple MCP server support
- Dynamic MCP server discovery
- UI indicators for MCP vs native tools
- MCP server health dashboard

### Advanced Features
- Custom MCP server development
- Tool composition (chaining MCP tools)
- Per-user MCP server configurations
- MCP tool analytics and usage tracking

## Files to Create/Modify

### New Files
```
src/agent/mcp/
‚îú‚îÄ‚îÄ mcp-manager.ts
‚îú‚îÄ‚îÄ types.ts
‚îî‚îÄ‚îÄ connection-pool.ts (optional)

src/config/
‚îî‚îÄ‚îÄ mcp.ts

src/services/
‚îî‚îÄ‚îÄ mcp-connection-service.ts (optional)
```

### Modified Files
```
src/agent/tools/index.ts
src/agent/llm/streaming/stream-processor.ts
src/config/index.ts
src/initialization/index.ts
package.json (if new dependencies needed)
```

## Conclusion

This integration will enable Shadow to leverage the growing MCP ecosystem while maintaining its existing robust tool architecture. The modular approach ensures that MCP failures don't impact core functionality, and the design allows for easy expansion to additional MCP servers in the future.

**Next Steps**: Begin with Phase 1 implementation, focusing on solid foundations before adding complexity. Thorough testing at each phase will ensure stability and reliability.